{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Fast and Easy to use microframework for the web. Description Crow is a C++ microframework for running web services. It uses routing similar to Python's Flask which makes it easy to use. It is also extremely fast, beating multiple existing C++ frameworks as well as non C++ frameworks. Features Easy Routing (similar to flask). Type-safe Handlers. Blazingly fast (see this benchmark and this benchmark ). Built in JSON support. Mustache based templating library ( crow::mustache ). Header only library (single header file available). Middleware support for extensions. HTTP/1.1 and Websocket support. Multi-part request and response support. Uses modern C++ (11/14) Still in development HTTP/2 support Documentation Available here . Examples Hello World #include \"crow.h\" int main () { crow :: SimpleApp app ; CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); app . port ( 18080 ). multithreaded (). run (); } JSON Response CROW_ROUTE ( app , \"/json\" ) ([]{ crow :: json :: wvalue x ; x [ \"message\" ] = \"Hello, World!\" ; return x ; }); Arguments CROW_ROUTE ( app , \"/hello/<int>\" ) ([]( int count ){ if ( count > 100 ) return crow :: response ( 400 ); std :: ostringstream os ; os << count << \" bottles of beer!\" ; return crow :: response ( os . str ()); }); Handler arguments type check at compile time // Compile error with message \"Handler type is mismatched with URL paramters\" CROW_ROUTE ( app , \"/another/<int>\" ) ([]( int a , int b ){ return crow :: response ( 500 ); }); Handling JSON Requests CROW_ROUTE ( app , \"/add_json\" ) . methods ( \"POST\" _method ) ([]( const crow :: request & req ){ auto x = crow :: json :: load ( req . body ); if ( ! x ) return crow :: response ( 400 ); int sum = x [ \"a\" ]. i () + x [ \"b\" ]. i (); std :: ostringstream os ; os << sum ; return crow :: response { os . str ()}; }); More examples can be found here . Setting Up / Building Available here .","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"#description","text":"Crow is a C++ microframework for running web services. It uses routing similar to Python's Flask which makes it easy to use. It is also extremely fast, beating multiple existing C++ frameworks as well as non C++ frameworks.","title":"Description"},{"location":"#features","text":"Easy Routing (similar to flask). Type-safe Handlers. Blazingly fast (see this benchmark and this benchmark ). Built in JSON support. Mustache based templating library ( crow::mustache ). Header only library (single header file available). Middleware support for extensions. HTTP/1.1 and Websocket support. Multi-part request and response support. Uses modern C++ (11/14)","title":"Features"},{"location":"#still-in-development","text":"HTTP/2 support","title":"Still in development"},{"location":"#documentation","text":"Available here .","title":"Documentation"},{"location":"#examples","text":"","title":"Examples"},{"location":"#hello-world","text":"#include \"crow.h\" int main () { crow :: SimpleApp app ; CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); app . port ( 18080 ). multithreaded (). run (); }","title":"Hello World"},{"location":"#json-response","text":"CROW_ROUTE ( app , \"/json\" ) ([]{ crow :: json :: wvalue x ; x [ \"message\" ] = \"Hello, World!\" ; return x ; });","title":"JSON Response"},{"location":"#arguments","text":"CROW_ROUTE ( app , \"/hello/<int>\" ) ([]( int count ){ if ( count > 100 ) return crow :: response ( 400 ); std :: ostringstream os ; os << count << \" bottles of beer!\" ; return crow :: response ( os . str ()); }); Handler arguments type check at compile time // Compile error with message \"Handler type is mismatched with URL paramters\" CROW_ROUTE ( app , \"/another/<int>\" ) ([]( int a , int b ){ return crow :: response ( 500 ); });","title":"Arguments"},{"location":"#handling-json-requests","text":"CROW_ROUTE ( app , \"/add_json\" ) . methods ( \"POST\" _method ) ([]( const crow :: request & req ){ auto x = crow :: json :: load ( req . body ); if ( ! x ) return crow :: response ( 400 ); int sum = x [ \"a\" ]. i () + x [ \"b\" ]. i (); std :: ostringstream os ; os << sum ; return crow :: response { os . str ()}; }); More examples can be found here .","title":"Handling JSON Requests"},{"location":"#setting-up-building","text":"Available here .","title":"Setting Up / Building"},{"location":"getting_started/setup/","text":"This page explains how to set Crow up for use with your project. Requirements C++ compiler with C++14 support. Continuous Testing on g++-9.3 and clang-7.0, AMD64 (x86_64) and Arm64 v8 boost library (1.70 or later). (optional) CMake and Python3 to build tests and/or examples. (optional) Linking with jemalloc/tcmalloc is recommended for speed. Installing Requirements Ubuntu sudo apt-get install libboost-all-dev OSX brew install boost Windows Download boost from here and install it Downloading Either run git clone https://github.com/mrozigor/crow.git or download crow_all.h from the releases section. You can also download a zip of the project on github. Includes folder Copy the /includes folder to your project's root folder. Add #include \"path/to/includes/crow.h\" to your .cpp file. For any middlewares, add #include \"path/to/includes/middlewares/some_middleware.h\" . Single header file If you've downloaded crow_all.h , you can skip to step 4. Make sure you have python 3 installed. Open a terminal (or cmd.exe ) instance in /path/to/crow/scripts . Run python merge_all.py ../include crow_all.h (replace / with \\ if you're on Windows). Copy the crow_all.h file to where you put your libraries (if you don't know where this is, you can put it anywhere). Add #include \"path/to/crow_all.h\" to your .cpp file. Note : All middlewares are included with the merged header file, if you would like to include or exclude middlewares use the -e or -i arguments. building via CLI To build a crow Project, do the following: GCC (G++) Release: g++ main.cpp -lpthread -lboost_system . Debug: g++ main.cpp -ggdb -lpthread -lboost_system -D CROW_ENABLE_DEBUG . SSL: g++ main.cpp -lssl -lcrypto -lpthread -lboost_system -D CROW_ENABLE_SSL . Clang Release: clang++ main.cpp -lpthread -lboost_system . Debug: clang++ main.cpp -g -lpthread -lboost_system -DCROW_ENABLE_DEBUG . SSL: clang++ main.cpp -lssl -lcrypto -lpthread -lboost_system -DCROW_ENABLE_SSL . Microsoft Visual Studio Help needed building via CMake Add the following to your CMakeLists.txt : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 find_package ( Threads ) find_package ( OpenSSL ) if ( OPENSSL_FOUND ) include_directories ( ${ OPENSSL_INCLUDE_DIR } ) endif () if ( NOT CMAKE_BUILD_TYPE ) message ( STATUS \"No build type selected, default to Release\" ) set ( CMAKE_BUILD_TYPE \"Release\" ) endif () if ( MSVC ) set ( Boost_USE_STATIC_LIBS \"On\" ) find_package ( Boost 1.70 COMPONENTS system thread regex REQUIRED ) else () find_package ( Boost 1.70 COMPONENTS system thread REQUIRED ) endif () include_directories ( ${ Boost_INCLUDE_DIR } ) set ( PROJECT_INCLUDE_DIR ${ PROJECT_SOURCE_DIR } /include ) include_directories ( \"${PROJECT_INCLUDE_DIR}\" ) Note : The last 2 lines are unnecessary if you're using crow_all.h . Building Crow tests and examples Out-of-source build with CMake is recommended. mkdir build cd build cmake .. make Running Cmake will create crow_all.h file and place it in the build directory. You can run tests with following commands: ctest -V","title":"Setup"},{"location":"getting_started/setup/#requirements","text":"C++ compiler with C++14 support. Continuous Testing on g++-9.3 and clang-7.0, AMD64 (x86_64) and Arm64 v8 boost library (1.70 or later). (optional) CMake and Python3 to build tests and/or examples. (optional) Linking with jemalloc/tcmalloc is recommended for speed.","title":"Requirements"},{"location":"getting_started/setup/#installing-requirements","text":"","title":"Installing Requirements"},{"location":"getting_started/setup/#ubuntu","text":"sudo apt-get install libboost-all-dev","title":"Ubuntu"},{"location":"getting_started/setup/#osx","text":"brew install boost","title":"OSX"},{"location":"getting_started/setup/#windows","text":"Download boost from here and install it","title":"Windows"},{"location":"getting_started/setup/#downloading","text":"Either run git clone https://github.com/mrozigor/crow.git or download crow_all.h from the releases section. You can also download a zip of the project on github.","title":"Downloading"},{"location":"getting_started/setup/#includes-folder","text":"Copy the /includes folder to your project's root folder. Add #include \"path/to/includes/crow.h\" to your .cpp file. For any middlewares, add #include \"path/to/includes/middlewares/some_middleware.h\" .","title":"Includes folder"},{"location":"getting_started/setup/#single-header-file","text":"If you've downloaded crow_all.h , you can skip to step 4. Make sure you have python 3 installed. Open a terminal (or cmd.exe ) instance in /path/to/crow/scripts . Run python merge_all.py ../include crow_all.h (replace / with \\ if you're on Windows). Copy the crow_all.h file to where you put your libraries (if you don't know where this is, you can put it anywhere). Add #include \"path/to/crow_all.h\" to your .cpp file. Note : All middlewares are included with the merged header file, if you would like to include or exclude middlewares use the -e or -i arguments.","title":"Single header file"},{"location":"getting_started/setup/#building-via-cli","text":"To build a crow Project, do the following:","title":"building via CLI"},{"location":"getting_started/setup/#gcc-g","text":"Release: g++ main.cpp -lpthread -lboost_system . Debug: g++ main.cpp -ggdb -lpthread -lboost_system -D CROW_ENABLE_DEBUG . SSL: g++ main.cpp -lssl -lcrypto -lpthread -lboost_system -D CROW_ENABLE_SSL .","title":"GCC (G++)"},{"location":"getting_started/setup/#clang","text":"Release: clang++ main.cpp -lpthread -lboost_system . Debug: clang++ main.cpp -g -lpthread -lboost_system -DCROW_ENABLE_DEBUG . SSL: clang++ main.cpp -lssl -lcrypto -lpthread -lboost_system -DCROW_ENABLE_SSL .","title":"Clang"},{"location":"getting_started/setup/#microsoft-visual-studio","text":"Help needed","title":"Microsoft Visual Studio"},{"location":"getting_started/setup/#building-via-cmake","text":"Add the following to your CMakeLists.txt : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 find_package ( Threads ) find_package ( OpenSSL ) if ( OPENSSL_FOUND ) include_directories ( ${ OPENSSL_INCLUDE_DIR } ) endif () if ( NOT CMAKE_BUILD_TYPE ) message ( STATUS \"No build type selected, default to Release\" ) set ( CMAKE_BUILD_TYPE \"Release\" ) endif () if ( MSVC ) set ( Boost_USE_STATIC_LIBS \"On\" ) find_package ( Boost 1.70 COMPONENTS system thread regex REQUIRED ) else () find_package ( Boost 1.70 COMPONENTS system thread REQUIRED ) endif () include_directories ( ${ Boost_INCLUDE_DIR } ) set ( PROJECT_INCLUDE_DIR ${ PROJECT_SOURCE_DIR } /include ) include_directories ( \"${PROJECT_INCLUDE_DIR}\" ) Note : The last 2 lines are unnecessary if you're using crow_all.h .","title":"building via CMake"},{"location":"getting_started/setup/#building-crow-tests-and-examples","text":"Out-of-source build with CMake is recommended. mkdir build cd build cmake .. make Running Cmake will create crow_all.h file and place it in the build directory. You can run tests with following commands: ctest -V","title":"Building Crow tests and examples"},{"location":"getting_started/your_first_application/","text":"This page shows how you can get started with a simple hello world application. 1. Include Starting with an empty main.cpp file, add #include \"crow.h\" or #include \"crow_all.h\" if you're using the single header file. 2. App declaration Next Create a main() and declare a crow :: SimpleApp inside, your code should look like this int main () { crow :: SimpleApp app ; } The App (or SimpleApp) class organizes all the different parts of Crow and provides the developer (you) a simple interface to interact with these parts. For more information, please go here . 3. Adding routes Once you have your app, the next step is to add routes (or endpoints). You can do so with the CROW_ROUTE macro. CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); For more details on routes, please go here . 4. Running the app Once you're happy with how you defined all your routes, you're going to want to instruct Crow to run your app. This is done using the run() method. app . port ( 18080 ). multithreaded (). run (); Please note that the port() and multithreaded() methods aren't needed, Though not using port() will cause the default port ( 80 ) to be used. Putting it all together Once you've followed all the steps above, your code should look similar to this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your crow application //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); //set the port, set the app to run on multiple threads, and run the app app . port ( 18080 ). multithreaded (). run (); } After building and running your .cpp file, you should be able to access your endpoint at http://localhost:18080 . Opening this URL in your browser will show a white screen with \"Hello world\" typed on it.","title":"Your First Application"},{"location":"getting_started/your_first_application/#1-include","text":"Starting with an empty main.cpp file, add #include \"crow.h\" or #include \"crow_all.h\" if you're using the single header file.","title":"1. Include"},{"location":"getting_started/your_first_application/#2-app-declaration","text":"Next Create a main() and declare a crow :: SimpleApp inside, your code should look like this int main () { crow :: SimpleApp app ; } The App (or SimpleApp) class organizes all the different parts of Crow and provides the developer (you) a simple interface to interact with these parts. For more information, please go here .","title":"2. App declaration"},{"location":"getting_started/your_first_application/#3-adding-routes","text":"Once you have your app, the next step is to add routes (or endpoints). You can do so with the CROW_ROUTE macro. CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); For more details on routes, please go here .","title":"3. Adding routes"},{"location":"getting_started/your_first_application/#4-running-the-app","text":"Once you're happy with how you defined all your routes, you're going to want to instruct Crow to run your app. This is done using the run() method. app . port ( 18080 ). multithreaded (). run (); Please note that the port() and multithreaded() methods aren't needed, Though not using port() will cause the default port ( 80 ) to be used.","title":"4. Running the app"},{"location":"getting_started/your_first_application/#putting-it-all-together","text":"Once you've followed all the steps above, your code should look similar to this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your crow application //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); //set the port, set the app to run on multiple threads, and run the app app . port ( 18080 ). multithreaded (). run (); } After building and running your .cpp file, you should be able to access your endpoint at http://localhost:18080 . Opening this URL in your browser will show a white screen with \"Hello world\" typed on it.","title":"Putting it all together"},{"location":"guides/app/","text":"A Crow app defines an interface to allow the developer access to all the different parts of the framework, without having to manually deal with each one. An app allows access to the http server (for handling connections), router (for handling URLs and requests), Middlewares (for extending Crow), amoung many others. Crow has 2 different app types: SimpleApp Has no middlewares. App<m1, m2, ...> Has middlewares. Using the app To use a Crow app, simply define crow :: SimpleApp or crow :: App < m1 , m2 ... > if you're using middlewares. The methods of an app can be chained. That means that you can configure and run your app in the same code line. app . bindaddr ( 192.168.1.2 ). port ( 443 ). ssl_file ( \"certfile.crt\" , \"keyfile.key\" ). multithreaded (). run (); Or if you like your code neat app . bindaddr ( 192.168.1.2 ) . port ( 443 ) . ssl_file ( \"certfile.crt\" , \"keyfile.key\" ) . multithreaded () . run (); For more info on middlewares, check out this page . For more info on what functions are available to a Crow app, go here .","title":"App"},{"location":"guides/app/#simpleapp","text":"Has no middlewares.","title":"SimpleApp"},{"location":"guides/app/#appm1-m2","text":"Has middlewares.","title":"App&lt;m1, m2, ...&gt;"},{"location":"guides/app/#using-the-app","text":"To use a Crow app, simply define crow :: SimpleApp or crow :: App < m1 , m2 ... > if you're using middlewares. The methods of an app can be chained. That means that you can configure and run your app in the same code line. app . bindaddr ( 192.168.1.2 ). port ( 443 ). ssl_file ( \"certfile.crt\" , \"keyfile.key\" ). multithreaded (). run (); Or if you like your code neat app . bindaddr ( 192.168.1.2 ) . port ( 443 ) . ssl_file ( \"certfile.crt\" , \"keyfile.key\" ) . multithreaded () . run (); For more info on middlewares, check out this page . For more info on what functions are available to a Crow app, go here .","title":"Using the app"},{"location":"guides/json/","text":"Crow has built in support for JSON data. rvalue JSON read value, used for taking a JSON string and parsing it into crow::json . You can read individual items of the rvalue, but you cannot add items to it. To do that, you need to convert it to a wvalue , which can be done by simply writing crow :: json :: wvalue wval ( rval ); (assuming rval is your rvalue ). For more info on read values go here . wvalue JSON write value, used for creating, editing and converting JSON to a string. The types of values that wvalue can take are as follows: False : from type bool . True : from type bool . Number Floating_point : from type double . Signed_integer : from type int . Unsigned_integer : from type unsigned int . String : from type std::string . List : from type std::vector . Object : from type crow::json::wvalue . This last type means that wvalue can have keys, this is done by simply assigning a value to whatever string key you like, something like wval [ \"key1\" ] = val1 ; . Keep in mind that val1 can be any of the above types. A JSON wvalue can be returned directly inside a route handler, this will cause the content-type header to automatically be set to Application/json and the JSON value will be converted to string and placed in the response body. For more information go to Routes . For more info on write values go here .","title":"JSON"},{"location":"guides/json/#rvalue","text":"JSON read value, used for taking a JSON string and parsing it into crow::json . You can read individual items of the rvalue, but you cannot add items to it. To do that, you need to convert it to a wvalue , which can be done by simply writing crow :: json :: wvalue wval ( rval ); (assuming rval is your rvalue ). For more info on read values go here .","title":"rvalue"},{"location":"guides/json/#wvalue","text":"JSON write value, used for creating, editing and converting JSON to a string. The types of values that wvalue can take are as follows: False : from type bool . True : from type bool . Number Floating_point : from type double . Signed_integer : from type int . Unsigned_integer : from type unsigned int . String : from type std::string . List : from type std::vector . Object : from type crow::json::wvalue . This last type means that wvalue can have keys, this is done by simply assigning a value to whatever string key you like, something like wval [ \"key1\" ] = val1 ; . Keep in mind that val1 can be any of the above types. A JSON wvalue can be returned directly inside a route handler, this will cause the content-type header to automatically be set to Application/json and the JSON value will be converted to string and placed in the response body. For more information go to Routes . For more info on write values go here .","title":"wvalue"},{"location":"guides/logging/","text":"Crow comes with a simple and easy to use logging system. Setting up logging level You can set up the level at which crow displays logs by using the app's loglevel(crow::logLevel) method. The available log levels are as follows (please not that setting a level will also display all logs below this level): Debug Info Warning Error Critical To set a logLevel, just use app . loglevel ( crow :: logLevel :: Warning ) , This will not show any debug or info logs. It will however still show error and critical logs. Please note that setting the Macro CROW_ENABLE_DEBUG during compilation will also set the log level to Debug . Writing a log Writing a log is as simple as CROW_LOG_ < LOG LEVEL > << \"Hello\" ; (replace<LOG LEVEL> with the actual level in all caps, so you have CROW_LOG_WARNING ).","title":"Logging"},{"location":"guides/logging/#setting-up-logging-level","text":"You can set up the level at which crow displays logs by using the app's loglevel(crow::logLevel) method. The available log levels are as follows (please not that setting a level will also display all logs below this level): Debug Info Warning Error Critical To set a logLevel, just use app . loglevel ( crow :: logLevel :: Warning ) , This will not show any debug or info logs. It will however still show error and critical logs. Please note that setting the Macro CROW_ENABLE_DEBUG during compilation will also set the log level to Debug .","title":"Setting up logging level"},{"location":"guides/logging/#writing-a-log","text":"Writing a log is as simple as CROW_LOG_ < LOG LEVEL > << \"Hello\" ; (replace<LOG LEVEL> with the actual level in all caps, so you have CROW_LOG_WARNING ).","title":"Writing a log"},{"location":"guides/middleware/","text":"Any middleware requires following 3 members: struct context Storing data for the middleware; can be read from another middleware or handlers before_handle Called before handling the request. If res.end() is called, the operation is halted. ( after_handle will still be called) 2 signatures: void before_handle ( request & req , response & res , context & ctx ) if you only need to access this middleware's context. template < typename AllContext > void before_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) You can access other middlewares' context by calling all_ctx . template get < MW > () ctx == all_ctx . template get < CurrentMiddleware > () after_handle Called after handling the request. void after_handle ( request & req , response & res , context & ctx ) template < typename AllContext > void after_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) This was pulled from cookie_parser.h . Further Editing required, possibly use parts of @ipkn's wiki page .","title":"Middleware"},{"location":"guides/middleware/#struct-context","text":"Storing data for the middleware; can be read from another middleware or handlers","title":"struct context"},{"location":"guides/middleware/#before_handle","text":"Called before handling the request. If res.end() is called, the operation is halted. ( after_handle will still be called) 2 signatures: void before_handle ( request & req , response & res , context & ctx ) if you only need to access this middleware's context. template < typename AllContext > void before_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) You can access other middlewares' context by calling all_ctx . template get < MW > () ctx == all_ctx . template get < CurrentMiddleware > ()","title":"before_handle"},{"location":"guides/middleware/#after_handle","text":"Called after handling the request. void after_handle ( request & req , response & res , context & ctx ) template < typename AllContext > void after_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) This was pulled from cookie_parser.h . Further Editing required, possibly use parts of @ipkn's wiki page .","title":"after_handle"},{"location":"guides/multipart/","text":"Multipart is a way of forming HTTP requests or responses to contain multiple distinct parts. Such an approach allows a request to contain multiple different pieces of data with potentially conflicting data types in a single response payload. It is typically used either in html forms, or when uploading multiple files. The structure of a multipart request is typically consistent of: A Header: Typically multipart/form-data;boundary=<boundary> , This defines the HTTP message as being multipart, as well as defining the separator used to distinguish the different parts. 1 or more parts: --<boundary> Part header: typically content-disposition: mime/type; name=\"<fieldname>\" ( mime/type should be replaced with the actual mime-type), can also contain a filename property (separated from the rest by a ; and structured similarly to the name property) Value --<boundary>-- Crow supports multipart requests and responses though crow::multipart::message . A message can be created either by defining the headers, boundary, and individual parts and using them to create the message. or simply by reading a crow::request . Once a multipart message has been made, the individual parts can be accessed throught mpmes.parts , parts is an std::vector , so accessing the individual parts should be straightforward. In order to access the individual part's name or filename, something like mpmes . parts [ 0 ]. headers [ 0 ]. params [ \"name\" ] sould do the trick. For more info on Multipart messages, go here","title":"Multipart"},{"location":"guides/proxies/","text":"HELP NEEDED","title":"Proxies"},{"location":"guides/routes/","text":"Routes define what happens when your client connects to a certain URL. Macro CROW_ROUTE(app, url) Can be replaced with app . route < crow :: black_magick :: get_parameter_tag ( url ) > ( url ) or app . route_dynamic ( url ) if you're using VS2013 or want runtime url evaluation. Although this usage is NOT recommended. App Which app class to assign the route to. Path (URL) Which relative path is assigned to the route. Using /hello means the client will need to access http://example.com/hello in order to access the route. A path can have parameters, for example /hello/<int> will allow a client to input an int into the url which will be in the handler (something like http://example.com/hello/42 ). Parameters can be <int> , <uint> , <double> , <string> , or <path> . It's worth nothing that the parameters also need to be defined in the handler, an example of using parameters would be to add 2 numbers based on input: CROW_ROUTE ( app , \"/add/<int>/<int>\" ) ([]( int a , int b ) { return std :: to_string ( a + b ); }); you can see the first <int> is defined as a and the second as b . If you were to run this and call http://example.com/add/1/2 , the result would be a page with 3 . Exciting! Handler Basically a piece of code that gets executed whenever the client calls the associated route, usually in the form of a lambda expression . It can be as simple as ([](){ return \"Hello World\" }) . Request Handlers can also use information from the request by adding it as a parameter ([]( const crow :: request & req ){...}) . You can also access the url parameters in the handler using req . url_params . get ( \"param_name\" ); . If the parameter doesn't exist, nullptr is returned. For more information on crow::request go here . Response Crow also provides the ability to define a response in the parameters by using ([]( const crow :: request & req , crow :: response & res ){...}) . If you don't want to use the request you can write ([]( const crow :: request & , crow :: response & res ){...}) . Please note that in order to return a response defined as a parameter you'll need to use res.end(); . Alternatively, you can define the response in the body and return it ( ([](){ return crow :: response ()}) ). For more information on crow::response go here . return statement A crow::response is very strictly tied to a route. If you can have something in a response constructor, you can return it in a handler. The main return type is std::string . although you could also return a crow::json::wvalue directly. (Support for more data types including third party libraries is coming soon) For more information on the specific constructors for a crow::response go here .","title":"Routes"},{"location":"guides/routes/#macro","text":"CROW_ROUTE(app, url) Can be replaced with app . route < crow :: black_magick :: get_parameter_tag ( url ) > ( url ) or app . route_dynamic ( url ) if you're using VS2013 or want runtime url evaluation. Although this usage is NOT recommended.","title":"Macro"},{"location":"guides/routes/#app","text":"Which app class to assign the route to.","title":"App"},{"location":"guides/routes/#path-url","text":"Which relative path is assigned to the route. Using /hello means the client will need to access http://example.com/hello in order to access the route. A path can have parameters, for example /hello/<int> will allow a client to input an int into the url which will be in the handler (something like http://example.com/hello/42 ). Parameters can be <int> , <uint> , <double> , <string> , or <path> . It's worth nothing that the parameters also need to be defined in the handler, an example of using parameters would be to add 2 numbers based on input: CROW_ROUTE ( app , \"/add/<int>/<int>\" ) ([]( int a , int b ) { return std :: to_string ( a + b ); }); you can see the first <int> is defined as a and the second as b . If you were to run this and call http://example.com/add/1/2 , the result would be a page with 3 . Exciting!","title":"Path (URL)"},{"location":"guides/routes/#handler","text":"Basically a piece of code that gets executed whenever the client calls the associated route, usually in the form of a lambda expression . It can be as simple as ([](){ return \"Hello World\" }) .","title":"Handler"},{"location":"guides/routes/#request","text":"Handlers can also use information from the request by adding it as a parameter ([]( const crow :: request & req ){...}) . You can also access the url parameters in the handler using req . url_params . get ( \"param_name\" ); . If the parameter doesn't exist, nullptr is returned. For more information on crow::request go here .","title":"Request"},{"location":"guides/routes/#response","text":"Crow also provides the ability to define a response in the parameters by using ([]( const crow :: request & req , crow :: response & res ){...}) . If you don't want to use the request you can write ([]( const crow :: request & , crow :: response & res ){...}) . Please note that in order to return a response defined as a parameter you'll need to use res.end(); . Alternatively, you can define the response in the body and return it ( ([](){ return crow :: response ()}) ). For more information on crow::response go here .","title":"Response"},{"location":"guides/routes/#return-statement","text":"A crow::response is very strictly tied to a route. If you can have something in a response constructor, you can return it in a handler. The main return type is std::string . although you could also return a crow::json::wvalue directly. (Support for more data types including third party libraries is coming soon) For more information on the specific constructors for a crow::response go here .","title":"return statement"},{"location":"guides/ssl/","text":"Crow supports HTTPS though SSL or TLS. When mentioning SSL in this documentation, it is often a reference to openSSL, which includes TLS. Don't worry, we don't use obsolete security standards :) To enable SSL, first your application needs to define either a .crt and .key files, or a .pem file. Once you have your files, you can add them to your app like this: app . ssl_file ( \"/path/to/cert.crt\" , \"/path/to/keyfile.key\" ) or app . ssl_file ( \"/path/to/pem_file.pem\" ) . Please note that this method can be part of the app method chain, which means it can be followed by .run() or any other method. You can also set your own SSL context (by using boost::asio::ssl::context ctx ) and then applying it via the app . ssl ( ctx ) method. IMPORTANT NOTICE : If you plan on using a proxy like Nginx or Apache2, DO NOT use SSL in crow, instead define it in your proxy instead and keep the connection between the proxy and Crow non-SSL.","title":"SSL"},{"location":"guides/static/","text":"A static file is any file that resides in the server's storage. Crow supports returning Static files as responses in 2 ways. Implicit Crow implicitly returns any static files placed in a static directory and any subdirectories, as long as the user calls the endpoint /static/path/to/file . The static folder or endpoint can be changed by defining the macros CROW_STATIC_DIRECTORY \"alternative_directory/\" and CROW_STATIC_ENDPOINT \"/alternative_endpoint/<path>\" . static directory changes the directory in the server's filesystem, while the endpoint changes the URL that the client needs to access. Explicit You can directly return a static file by using the crow::response method response . set_static_file_info ( \"path/to/file\" ); . The path is relative to the executable unless preceded by / , then it is an absolute path. Please keep in mind that using the set_static_file_info method does invalidate any data already in your response body. Note : Crow sets the content-type header automatically based on the file's extension, if an extension is unavailable or undefined, Crow uses text/plain , if you'd like to explicitly set a content-type , use response . set_header ( \"content-type\" , \"mime/type\" ); AFTER calling set_static_file_info .","title":"Static Files"},{"location":"guides/static/#implicit","text":"Crow implicitly returns any static files placed in a static directory and any subdirectories, as long as the user calls the endpoint /static/path/to/file . The static folder or endpoint can be changed by defining the macros CROW_STATIC_DIRECTORY \"alternative_directory/\" and CROW_STATIC_ENDPOINT \"/alternative_endpoint/<path>\" . static directory changes the directory in the server's filesystem, while the endpoint changes the URL that the client needs to access.","title":"Implicit"},{"location":"guides/static/#explicit","text":"You can directly return a static file by using the crow::response method response . set_static_file_info ( \"path/to/file\" ); . The path is relative to the executable unless preceded by / , then it is an absolute path. Please keep in mind that using the set_static_file_info method does invalidate any data already in your response body. Note : Crow sets the content-type header automatically based on the file's extension, if an extension is unavailable or undefined, Crow uses text/plain , if you'd like to explicitly set a content-type , use response . set_header ( \"content-type\" , \"mime/type\" ); AFTER calling set_static_file_info .","title":"Explicit"},{"location":"guides/syste/","text":"","title":"Systemd run on startup"},{"location":"guides/templating/","text":"Templating is when you return an html page with custom data. You can probably tell why that's useful. Crow supports mustache for templates through its own implementation crow::mustache . Components of mustache There are 2 components of a mustache template implementation: Page Context Page The HTML page (including the mustache tags). It is usually loaded into crow::mustache::template_t . It needs to be placed in templates directory (relative to where the crow executable is). For more information on how to formulate a template, see this mustache manual . Context A JSON object containing the tags as keys and their values. crow::mustache::context is actually a crow::json::wvalue . Returning a template To return a mustache template, you need to load a page using auto page = crow :: mustache :: load ( \"path/to/template.html\" ); , keep in mind that the path is relative to the templates directory. You also need to set up the context by using crow :: mustache :: context ctx ; . Then you need to assign the keys and values, this can be done the same way you assign values to a json write value ( ctx[\"key\"] = value; ). With your context and page ready, just return page . render ( ctx ); . This will use the context data to return a filled template. Alternatively you could just render the page without a context using return page . render (); .","title":"Templating (Mustache)"},{"location":"guides/templating/#components-of-mustache","text":"There are 2 components of a mustache template implementation: Page Context","title":"Components of mustache"},{"location":"guides/templating/#page","text":"The HTML page (including the mustache tags). It is usually loaded into crow::mustache::template_t . It needs to be placed in templates directory (relative to where the crow executable is). For more information on how to formulate a template, see this mustache manual .","title":"Page"},{"location":"guides/templating/#context","text":"A JSON object containing the tags as keys and their values. crow::mustache::context is actually a crow::json::wvalue .","title":"Context"},{"location":"guides/templating/#returning-a-template","text":"To return a mustache template, you need to load a page using auto page = crow :: mustache :: load ( \"path/to/template.html\" ); , keep in mind that the path is relative to the templates directory. You also need to set up the context by using crow :: mustache :: context ctx ; . Then you need to assign the keys and values, this can be done the same way you assign values to a json write value ( ctx[\"key\"] = value; ). With your context and page ready, just return page . render ( ctx ); . This will use the context data to return a filled template. Alternatively you could just render the page without a context using return page . render (); .","title":"Returning a template"},{"location":"guides/websockets/","text":"Websockets are a way of connecting a client and a server without the request response nature of HTTP. To create a websocket in Crow, you need a websocket route. A websocket route differs from a normal route quite a bit. While it uses the same CROW_ROUTE(app, \"/url\") macro, that's about where the similarities end. A websocket route follows the macro with .websocket() which is then followed by a series of methods (with handlers inside) for each event. These are: onopen ([ & ]( crow :: websocket :: connection & conn ){ handler code goes here }) onaccept ([ & ]( const crow :: request & ){ handler code goes here }) (This handler has to return bool) onmessage ([ & ]( crow :: websocket :: connection & conn , const std :: string message , bool is_binary ){ handler code goes here }) onclose ([ & ]( crow :: websocket :: connection & conn , const std :: string reason ){ handler code goes here }) onerror ([ & ]( crow :: websocket :: connection & conn ){ handler code goes here }) These event methods and their handlers can be chained. The full Route should look similar to this: CROW_ROUTE ( app , \"/ws\" ) . websocket () . onopen ([ & ]( crow :: websocket :: connection & conn ){ do_something (); }) . onclose ([ & ]( crow :: websocket :: connection & conn , const std :: string & reason ){ do_something (); }) . onmessage ([ & ]( crow :: websocket :: connection & /*conn*/ , const std :: string & data , bool is_binary ){ if ( is_binary ) do_something ( data ); else do_something_else ( data ); }); For more info go here .","title":"Websockets"}]}